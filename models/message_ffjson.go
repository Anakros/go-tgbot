// DO NOT EDIT!
// Code generated by ffjson <https://github.com/pquerna/ffjson>
// source: models/message.go
// DO NOT EDIT!

package models

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

func (mj *Message) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Message) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Audio != nil {
		if true {
			buf.WriteString(`"audio":`)

			{

				err = mj.Audio.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(mj.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(mj.Caption))
		buf.WriteByte(',')
	}
	if mj.ChannelChatCreated != false {
		if mj.ChannelChatCreated {
			buf.WriteString(`"channel_chat_created":true`)
		} else {
			buf.WriteString(`"channel_chat_created":false`)
		}
		buf.WriteByte(',')
	}
	if mj.Chat != nil {
		if true {
			buf.WriteString(`"chat":`)

			{

				err = mj.Chat.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Contact != nil {
		if true {
			buf.WriteString(`"contact":`)

			{

				err = mj.Contact.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Date != 0 {
		buf.WriteString(`"date":`)
		fflib.FormatBits2(buf, uint64(mj.Date), 10, mj.Date < 0)
		buf.WriteByte(',')
	}
	if mj.DeleteChatPhoto != false {
		if mj.DeleteChatPhoto {
			buf.WriteString(`"delete_chat_photo":true`)
		} else {
			buf.WriteString(`"delete_chat_photo":false`)
		}
		buf.WriteByte(',')
	}
	if mj.Document != nil {
		if true {
			buf.WriteString(`"document":`)

			{

				err = mj.Document.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.EditDate != 0 {
		buf.WriteString(`"edit_date":`)
		fflib.FormatBits2(buf, uint64(mj.EditDate), 10, mj.EditDate < 0)
		buf.WriteByte(',')
	}
	buf.WriteString(`"entities":`)
	if mj.Entities != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Entities {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				/* Struct fall back. type=models.MessageEntity kind=struct */
				err = buf.Encode(&v)
				if err != nil {
					return err
				}
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if mj.ForwardDate != 0 {
		buf.WriteString(`"forward_date":`)
		fflib.FormatBits2(buf, uint64(mj.ForwardDate), 10, mj.ForwardDate < 0)
		buf.WriteByte(',')
	}
	if mj.ForwardFrom != nil {
		if true {
			/* Struct fall back. type=models.User kind=struct */
			buf.WriteString(`"forward_from":`)
			err = buf.Encode(mj.ForwardFrom)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	if mj.ForwardFromChat != nil {
		if true {
			buf.WriteString(`"forward_from_chat":`)

			{

				err = mj.ForwardFromChat.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.ForwardFromMessageID != 0 {
		buf.WriteString(`"forward_from_message_id":`)
		fflib.FormatBits2(buf, uint64(mj.ForwardFromMessageID), 10, mj.ForwardFromMessageID < 0)
		buf.WriteByte(',')
	}
	if mj.From != nil {
		if true {
			/* Struct fall back. type=models.User kind=struct */
			buf.WriteString(`"from":`)
			err = buf.Encode(mj.From)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	if mj.Game != nil {
		if true {
			buf.WriteString(`"game":`)

			{

				err = mj.Game.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.GroupChatCreated != false {
		if mj.GroupChatCreated {
			buf.WriteString(`"group_chat_created":true`)
		} else {
			buf.WriteString(`"group_chat_created":false`)
		}
		buf.WriteByte(',')
	}
	if mj.LeftChatMember != nil {
		if true {
			/* Struct fall back. type=models.User kind=struct */
			buf.WriteString(`"left_chat_member":`)
			err = buf.Encode(mj.LeftChatMember)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	if mj.Location != nil {
		if true {
			buf.WriteString(`"location":`)

			{

				err = mj.Location.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.MessageID != 0 {
		buf.WriteString(`"message_id":`)
		fflib.FormatBits2(buf, uint64(mj.MessageID), 10, mj.MessageID < 0)
		buf.WriteByte(',')
	}
	if mj.MigrateFromChatID != 0 {
		buf.WriteString(`"migrate_from_chat_id":`)
		fflib.FormatBits2(buf, uint64(mj.MigrateFromChatID), 10, mj.MigrateFromChatID < 0)
		buf.WriteByte(',')
	}
	if mj.MigrateToChatID != 0 {
		buf.WriteString(`"migrate_to_chat_id":`)
		fflib.FormatBits2(buf, uint64(mj.MigrateToChatID), 10, mj.MigrateToChatID < 0)
		buf.WriteByte(',')
	}
	if mj.NewChatMember != nil {
		if true {
			/* Struct fall back. type=models.User kind=struct */
			buf.WriteString(`"new_chat_member":`)
			err = buf.Encode(mj.NewChatMember)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"new_chat_photo":`)
	if mj.NewChatPhoto != nil {
		buf.WriteString(`[`)
		for i, v := range mj.NewChatPhoto {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				/* Struct fall back. type=models.PhotoSize kind=struct */
				err = buf.Encode(&v)
				if err != nil {
					return err
				}
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(mj.NewChatTitle) != 0 {
		buf.WriteString(`"new_chat_title":`)
		fflib.WriteJsonString(buf, string(mj.NewChatTitle))
		buf.WriteByte(',')
	}
	buf.WriteString(`"photo":`)
	if mj.Photo != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Photo {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				/* Struct fall back. type=models.PhotoSize kind=struct */
				err = buf.Encode(&v)
				if err != nil {
					return err
				}
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if mj.PinnedMessage != nil {
		if true {
			buf.WriteString(`"pinned_message":`)

			{

				err = mj.PinnedMessage.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.ReplyToMessage != nil {
		if true {
			buf.WriteString(`"reply_to_message":`)

			{

				err = mj.ReplyToMessage.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Sticker != nil {
		if true {
			/* Struct fall back. type=models.Sticker kind=struct */
			buf.WriteString(`"sticker":`)
			err = buf.Encode(mj.Sticker)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	if mj.SupergroupChatCreated != false {
		if mj.SupergroupChatCreated {
			buf.WriteString(`"supergroup_chat_created":true`)
		} else {
			buf.WriteString(`"supergroup_chat_created":false`)
		}
		buf.WriteByte(',')
	}
	if len(mj.Text) != 0 {
		buf.WriteString(`"text":`)
		fflib.WriteJsonString(buf, string(mj.Text))
		buf.WriteByte(',')
	}
	if mj.Venue != nil {
		if true {
			/* Struct fall back. type=models.Venue kind=struct */
			buf.WriteString(`"venue":`)
			err = buf.Encode(mj.Venue)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	if mj.Video != nil {
		if true {
			/* Struct fall back. type=models.Video kind=struct */
			buf.WriteString(`"video":`)
			err = buf.Encode(mj.Video)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	if mj.Voice != nil {
		if true {
			/* Struct fall back. type=models.Voice kind=struct */
			buf.WriteString(`"voice":`)
			err = buf.Encode(mj.Voice)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Messagebase = iota
	ffj_t_Messageno_such_key

	ffj_t_Message_Audio

	ffj_t_Message_Caption

	ffj_t_Message_ChannelChatCreated

	ffj_t_Message_Chat

	ffj_t_Message_Contact

	ffj_t_Message_Date

	ffj_t_Message_DeleteChatPhoto

	ffj_t_Message_Document

	ffj_t_Message_EditDate

	ffj_t_Message_Entities

	ffj_t_Message_ForwardDate

	ffj_t_Message_ForwardFrom

	ffj_t_Message_ForwardFromChat

	ffj_t_Message_ForwardFromMessageID

	ffj_t_Message_From

	ffj_t_Message_Game

	ffj_t_Message_GroupChatCreated

	ffj_t_Message_LeftChatMember

	ffj_t_Message_Location

	ffj_t_Message_MessageID

	ffj_t_Message_MigrateFromChatID

	ffj_t_Message_MigrateToChatID

	ffj_t_Message_NewChatMember

	ffj_t_Message_NewChatPhoto

	ffj_t_Message_NewChatTitle

	ffj_t_Message_Photo

	ffj_t_Message_PinnedMessage

	ffj_t_Message_ReplyToMessage

	ffj_t_Message_Sticker

	ffj_t_Message_SupergroupChatCreated

	ffj_t_Message_Text

	ffj_t_Message_Venue

	ffj_t_Message_Video

	ffj_t_Message_Voice
)

var ffj_key_Message_Audio = []byte("audio")

var ffj_key_Message_Caption = []byte("caption")

var ffj_key_Message_ChannelChatCreated = []byte("channel_chat_created")

var ffj_key_Message_Chat = []byte("chat")

var ffj_key_Message_Contact = []byte("contact")

var ffj_key_Message_Date = []byte("date")

var ffj_key_Message_DeleteChatPhoto = []byte("delete_chat_photo")

var ffj_key_Message_Document = []byte("document")

var ffj_key_Message_EditDate = []byte("edit_date")

var ffj_key_Message_Entities = []byte("entities")

var ffj_key_Message_ForwardDate = []byte("forward_date")

var ffj_key_Message_ForwardFrom = []byte("forward_from")

var ffj_key_Message_ForwardFromChat = []byte("forward_from_chat")

var ffj_key_Message_ForwardFromMessageID = []byte("forward_from_message_id")

var ffj_key_Message_From = []byte("from")

var ffj_key_Message_Game = []byte("game")

var ffj_key_Message_GroupChatCreated = []byte("group_chat_created")

var ffj_key_Message_LeftChatMember = []byte("left_chat_member")

var ffj_key_Message_Location = []byte("location")

var ffj_key_Message_MessageID = []byte("message_id")

var ffj_key_Message_MigrateFromChatID = []byte("migrate_from_chat_id")

var ffj_key_Message_MigrateToChatID = []byte("migrate_to_chat_id")

var ffj_key_Message_NewChatMember = []byte("new_chat_member")

var ffj_key_Message_NewChatPhoto = []byte("new_chat_photo")

var ffj_key_Message_NewChatTitle = []byte("new_chat_title")

var ffj_key_Message_Photo = []byte("photo")

var ffj_key_Message_PinnedMessage = []byte("pinned_message")

var ffj_key_Message_ReplyToMessage = []byte("reply_to_message")

var ffj_key_Message_Sticker = []byte("sticker")

var ffj_key_Message_SupergroupChatCreated = []byte("supergroup_chat_created")

var ffj_key_Message_Text = []byte("text")

var ffj_key_Message_Venue = []byte("venue")

var ffj_key_Message_Video = []byte("video")

var ffj_key_Message_Voice = []byte("voice")

func (uj *Message) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Message) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Messagebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Messageno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_Message_Audio, kn) {
						currentKey = ffj_t_Message_Audio
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_Message_Caption, kn) {
						currentKey = ffj_t_Message_Caption
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_ChannelChatCreated, kn) {
						currentKey = ffj_t_Message_ChannelChatCreated
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_Chat, kn) {
						currentKey = ffj_t_Message_Chat
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_Contact, kn) {
						currentKey = ffj_t_Message_Contact
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_Message_Date, kn) {
						currentKey = ffj_t_Message_Date
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_DeleteChatPhoto, kn) {
						currentKey = ffj_t_Message_DeleteChatPhoto
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_Document, kn) {
						currentKey = ffj_t_Message_Document
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_Message_EditDate, kn) {
						currentKey = ffj_t_Message_EditDate
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_Entities, kn) {
						currentKey = ffj_t_Message_Entities
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_Message_ForwardDate, kn) {
						currentKey = ffj_t_Message_ForwardDate
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_ForwardFrom, kn) {
						currentKey = ffj_t_Message_ForwardFrom
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_ForwardFromChat, kn) {
						currentKey = ffj_t_Message_ForwardFromChat
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_ForwardFromMessageID, kn) {
						currentKey = ffj_t_Message_ForwardFromMessageID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_From, kn) {
						currentKey = ffj_t_Message_From
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffj_key_Message_Game, kn) {
						currentKey = ffj_t_Message_Game
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_GroupChatCreated, kn) {
						currentKey = ffj_t_Message_GroupChatCreated
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_Message_LeftChatMember, kn) {
						currentKey = ffj_t_Message_LeftChatMember
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_Location, kn) {
						currentKey = ffj_t_Message_Location
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_Message_MessageID, kn) {
						currentKey = ffj_t_Message_MessageID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_MigrateFromChatID, kn) {
						currentKey = ffj_t_Message_MigrateFromChatID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_MigrateToChatID, kn) {
						currentKey = ffj_t_Message_MigrateToChatID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_Message_NewChatMember, kn) {
						currentKey = ffj_t_Message_NewChatMember
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_NewChatPhoto, kn) {
						currentKey = ffj_t_Message_NewChatPhoto
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_NewChatTitle, kn) {
						currentKey = ffj_t_Message_NewChatTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_Message_Photo, kn) {
						currentKey = ffj_t_Message_Photo
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_PinnedMessage, kn) {
						currentKey = ffj_t_Message_PinnedMessage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_Message_ReplyToMessage, kn) {
						currentKey = ffj_t_Message_ReplyToMessage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Message_Sticker, kn) {
						currentKey = ffj_t_Message_Sticker
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_SupergroupChatCreated, kn) {
						currentKey = ffj_t_Message_SupergroupChatCreated
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Message_Text, kn) {
						currentKey = ffj_t_Message_Text
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_Message_Venue, kn) {
						currentKey = ffj_t_Message_Venue
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_Video, kn) {
						currentKey = ffj_t_Message_Video
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_Voice, kn) {
						currentKey = ffj_t_Message_Voice
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Message_Voice, kn) {
					currentKey = ffj_t_Message_Voice
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Message_Video, kn) {
					currentKey = ffj_t_Message_Video
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Message_Venue, kn) {
					currentKey = ffj_t_Message_Venue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Message_Text, kn) {
					currentKey = ffj_t_Message_Text
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Message_SupergroupChatCreated, kn) {
					currentKey = ffj_t_Message_SupergroupChatCreated
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Message_Sticker, kn) {
					currentKey = ffj_t_Message_Sticker
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Message_ReplyToMessage, kn) {
					currentKey = ffj_t_Message_ReplyToMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Message_PinnedMessage, kn) {
					currentKey = ffj_t_Message_PinnedMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Message_Photo, kn) {
					currentKey = ffj_t_Message_Photo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Message_NewChatTitle, kn) {
					currentKey = ffj_t_Message_NewChatTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Message_NewChatPhoto, kn) {
					currentKey = ffj_t_Message_NewChatPhoto
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Message_NewChatMember, kn) {
					currentKey = ffj_t_Message_NewChatMember
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Message_MigrateToChatID, kn) {
					currentKey = ffj_t_Message_MigrateToChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Message_MigrateFromChatID, kn) {
					currentKey = ffj_t_Message_MigrateFromChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Message_MessageID, kn) {
					currentKey = ffj_t_Message_MessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Message_Location, kn) {
					currentKey = ffj_t_Message_Location
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Message_LeftChatMember, kn) {
					currentKey = ffj_t_Message_LeftChatMember
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Message_GroupChatCreated, kn) {
					currentKey = ffj_t_Message_GroupChatCreated
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Message_Game, kn) {
					currentKey = ffj_t_Message_Game
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Message_From, kn) {
					currentKey = ffj_t_Message_From
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Message_ForwardFromMessageID, kn) {
					currentKey = ffj_t_Message_ForwardFromMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Message_ForwardFromChat, kn) {
					currentKey = ffj_t_Message_ForwardFromChat
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Message_ForwardFrom, kn) {
					currentKey = ffj_t_Message_ForwardFrom
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Message_ForwardDate, kn) {
					currentKey = ffj_t_Message_ForwardDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Message_Entities, kn) {
					currentKey = ffj_t_Message_Entities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Message_EditDate, kn) {
					currentKey = ffj_t_Message_EditDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Message_Document, kn) {
					currentKey = ffj_t_Message_Document
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Message_DeleteChatPhoto, kn) {
					currentKey = ffj_t_Message_DeleteChatPhoto
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Message_Date, kn) {
					currentKey = ffj_t_Message_Date
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Message_Contact, kn) {
					currentKey = ffj_t_Message_Contact
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Message_Chat, kn) {
					currentKey = ffj_t_Message_Chat
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Message_ChannelChatCreated, kn) {
					currentKey = ffj_t_Message_ChannelChatCreated
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Message_Caption, kn) {
					currentKey = ffj_t_Message_Caption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Message_Audio, kn) {
					currentKey = ffj_t_Message_Audio
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Messageno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Message_Audio:
					goto handle_Audio

				case ffj_t_Message_Caption:
					goto handle_Caption

				case ffj_t_Message_ChannelChatCreated:
					goto handle_ChannelChatCreated

				case ffj_t_Message_Chat:
					goto handle_Chat

				case ffj_t_Message_Contact:
					goto handle_Contact

				case ffj_t_Message_Date:
					goto handle_Date

				case ffj_t_Message_DeleteChatPhoto:
					goto handle_DeleteChatPhoto

				case ffj_t_Message_Document:
					goto handle_Document

				case ffj_t_Message_EditDate:
					goto handle_EditDate

				case ffj_t_Message_Entities:
					goto handle_Entities

				case ffj_t_Message_ForwardDate:
					goto handle_ForwardDate

				case ffj_t_Message_ForwardFrom:
					goto handle_ForwardFrom

				case ffj_t_Message_ForwardFromChat:
					goto handle_ForwardFromChat

				case ffj_t_Message_ForwardFromMessageID:
					goto handle_ForwardFromMessageID

				case ffj_t_Message_From:
					goto handle_From

				case ffj_t_Message_Game:
					goto handle_Game

				case ffj_t_Message_GroupChatCreated:
					goto handle_GroupChatCreated

				case ffj_t_Message_LeftChatMember:
					goto handle_LeftChatMember

				case ffj_t_Message_Location:
					goto handle_Location

				case ffj_t_Message_MessageID:
					goto handle_MessageID

				case ffj_t_Message_MigrateFromChatID:
					goto handle_MigrateFromChatID

				case ffj_t_Message_MigrateToChatID:
					goto handle_MigrateToChatID

				case ffj_t_Message_NewChatMember:
					goto handle_NewChatMember

				case ffj_t_Message_NewChatPhoto:
					goto handle_NewChatPhoto

				case ffj_t_Message_NewChatTitle:
					goto handle_NewChatTitle

				case ffj_t_Message_Photo:
					goto handle_Photo

				case ffj_t_Message_PinnedMessage:
					goto handle_PinnedMessage

				case ffj_t_Message_ReplyToMessage:
					goto handle_ReplyToMessage

				case ffj_t_Message_Sticker:
					goto handle_Sticker

				case ffj_t_Message_SupergroupChatCreated:
					goto handle_SupergroupChatCreated

				case ffj_t_Message_Text:
					goto handle_Text

				case ffj_t_Message_Venue:
					goto handle_Venue

				case ffj_t_Message_Video:
					goto handle_Video

				case ffj_t_Message_Voice:
					goto handle_Voice

				case ffj_t_Messageno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Audio:

	/* handler: uj.Audio type=models.Audio kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Audio = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Audio == nil {
			uj.Audio = new(Audio)
		}

		err = uj.Audio.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: uj.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelChatCreated:

	/* handler: uj.ChannelChatCreated type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.ChannelChatCreated = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.ChannelChatCreated = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Chat:

	/* handler: uj.Chat type=models.Chat kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Chat = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Chat == nil {
			uj.Chat = new(Chat)
		}

		err = uj.Chat.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Contact:

	/* handler: uj.Contact type=models.Contact kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Contact = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Contact == nil {
			uj.Contact = new(Contact)
		}

		err = uj.Contact.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Date:

	/* handler: uj.Date type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Date = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DeleteChatPhoto:

	/* handler: uj.DeleteChatPhoto type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.DeleteChatPhoto = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.DeleteChatPhoto = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Document:

	/* handler: uj.Document type=models.Document kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Document = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Document == nil {
			uj.Document = new(Document)
		}

		err = uj.Document.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EditDate:

	/* handler: uj.EditDate type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.EditDate = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Entities:

	/* handler: uj.Entities type=[]*models.MessageEntity kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Entities = nil
		} else {

			uj.Entities = []*MessageEntity{}

			wantVal := true

			for {

				var tmp_uj__Entities *MessageEntity

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__Entities type=*models.MessageEntity kind=ptr quoted=false*/

				{

					if tok == fflib.FFTok_null {
						tmp_uj__Entities = nil
					} else {
						if tmp_uj__Entities == nil {
							tmp_uj__Entities = new(MessageEntity)
						}

						/* handler: tmp_uj__Entities type=models.MessageEntity kind=struct quoted=false*/

						{
							/* Falling back. type=models.MessageEntity kind=struct */
							tbuf, err := fs.CaptureField(tok)
							if err != nil {
								return fs.WrapErr(err)
							}

							err = json.Unmarshal(tbuf, &tmp_uj__Entities)
							if err != nil {
								return fs.WrapErr(err)
							}
						}

					}
				}

				uj.Entities = append(uj.Entities, tmp_uj__Entities)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForwardDate:

	/* handler: uj.ForwardDate type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ForwardDate = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForwardFrom:

	/* handler: uj.ForwardFrom type=models.User kind=struct quoted=false*/

	{
		/* Falling back. type=models.User kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.ForwardFrom)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForwardFromChat:

	/* handler: uj.ForwardFromChat type=models.Chat kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ForwardFromChat = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ForwardFromChat == nil {
			uj.ForwardFromChat = new(Chat)
		}

		err = uj.ForwardFromChat.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForwardFromMessageID:

	/* handler: uj.ForwardFromMessageID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ForwardFromMessageID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_From:

	/* handler: uj.From type=models.User kind=struct quoted=false*/

	{
		/* Falling back. type=models.User kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.From)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Game:

	/* handler: uj.Game type=models.Game kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Game = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Game == nil {
			uj.Game = new(Game)
		}

		err = uj.Game.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GroupChatCreated:

	/* handler: uj.GroupChatCreated type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.GroupChatCreated = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.GroupChatCreated = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LeftChatMember:

	/* handler: uj.LeftChatMember type=models.User kind=struct quoted=false*/

	{
		/* Falling back. type=models.User kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.LeftChatMember)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Location:

	/* handler: uj.Location type=models.Location kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Location = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Location == nil {
			uj.Location = new(Location)
		}

		err = uj.Location.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MessageID:

	/* handler: uj.MessageID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.MessageID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MigrateFromChatID:

	/* handler: uj.MigrateFromChatID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.MigrateFromChatID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MigrateToChatID:

	/* handler: uj.MigrateToChatID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.MigrateToChatID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NewChatMember:

	/* handler: uj.NewChatMember type=models.User kind=struct quoted=false*/

	{
		/* Falling back. type=models.User kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.NewChatMember)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NewChatPhoto:

	/* handler: uj.NewChatPhoto type=[]*models.PhotoSize kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.NewChatPhoto = nil
		} else {

			uj.NewChatPhoto = []*PhotoSize{}

			wantVal := true

			for {

				var tmp_uj__NewChatPhoto *PhotoSize

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__NewChatPhoto type=*models.PhotoSize kind=ptr quoted=false*/

				{

					if tok == fflib.FFTok_null {
						tmp_uj__NewChatPhoto = nil
					} else {
						if tmp_uj__NewChatPhoto == nil {
							tmp_uj__NewChatPhoto = new(PhotoSize)
						}

						/* handler: tmp_uj__NewChatPhoto type=models.PhotoSize kind=struct quoted=false*/

						{
							/* Falling back. type=models.PhotoSize kind=struct */
							tbuf, err := fs.CaptureField(tok)
							if err != nil {
								return fs.WrapErr(err)
							}

							err = json.Unmarshal(tbuf, &tmp_uj__NewChatPhoto)
							if err != nil {
								return fs.WrapErr(err)
							}
						}

					}
				}

				uj.NewChatPhoto = append(uj.NewChatPhoto, tmp_uj__NewChatPhoto)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NewChatTitle:

	/* handler: uj.NewChatTitle type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.NewChatTitle = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Photo:

	/* handler: uj.Photo type=[]*models.PhotoSize kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Photo = nil
		} else {

			uj.Photo = []*PhotoSize{}

			wantVal := true

			for {

				var tmp_uj__Photo *PhotoSize

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__Photo type=*models.PhotoSize kind=ptr quoted=false*/

				{

					if tok == fflib.FFTok_null {
						tmp_uj__Photo = nil
					} else {
						if tmp_uj__Photo == nil {
							tmp_uj__Photo = new(PhotoSize)
						}

						/* handler: tmp_uj__Photo type=models.PhotoSize kind=struct quoted=false*/

						{
							/* Falling back. type=models.PhotoSize kind=struct */
							tbuf, err := fs.CaptureField(tok)
							if err != nil {
								return fs.WrapErr(err)
							}

							err = json.Unmarshal(tbuf, &tmp_uj__Photo)
							if err != nil {
								return fs.WrapErr(err)
							}
						}

					}
				}

				uj.Photo = append(uj.Photo, tmp_uj__Photo)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PinnedMessage:

	/* handler: uj.PinnedMessage type=models.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.PinnedMessage = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.PinnedMessage == nil {
			uj.PinnedMessage = new(Message)
		}

		err = uj.PinnedMessage.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyToMessage:

	/* handler: uj.ReplyToMessage type=models.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ReplyToMessage = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ReplyToMessage == nil {
			uj.ReplyToMessage = new(Message)
		}

		err = uj.ReplyToMessage.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Sticker:

	/* handler: uj.Sticker type=models.Sticker kind=struct quoted=false*/

	{
		/* Falling back. type=models.Sticker kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Sticker)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SupergroupChatCreated:

	/* handler: uj.SupergroupChatCreated type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.SupergroupChatCreated = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.SupergroupChatCreated = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Text:

	/* handler: uj.Text type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Text = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Venue:

	/* handler: uj.Venue type=models.Venue kind=struct quoted=false*/

	{
		/* Falling back. type=models.Venue kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Venue)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Video:

	/* handler: uj.Video type=models.Video kind=struct quoted=false*/

	{
		/* Falling back. type=models.Video kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Video)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Voice:

	/* handler: uj.Voice type=models.Voice kind=struct quoted=false*/

	{
		/* Falling back. type=models.Voice kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Voice)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}
